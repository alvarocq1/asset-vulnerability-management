import pandas as pd
import numpy as np
import psycopg2

# Conexión a la base de datos
print("Connecting to the database...")
conn = psycopg2.connect(
    dbname="project_db",
    user="acarriq",
    password="3432576",
    host="localhost",
    port="5432"
)

# Crear un cursor
cur = conn.cursor()

# Extraer datos de la tabla scan_results
query = "SELECT * FROM scan_results WHERE cvss_type = 'cvss_base_v3'"
df = pd.read_sql_query(query, conn)

# Definir métricas CVSS 3.1
cvss_v3_metrics = {
    'AV': {'N': 0.85, 'A': 0.62, 'L': 0.55, 'P': 0.2},
    'AC': {'L': 0.77, 'H': 0.44},
    'PR': {'N': 0.85, 'L': 0.62, 'H': 0.27},  # Assuming Scope Unchanged
    'UI': {'N': 0.85, 'R': 0.62},
    'E': {'X': 1.0, 'H': 1.0, 'F': 0.97, 'P': 0.94, 'U': 0.91}  # Valores actualizados para Exploitability
}

# Función para calcular VAD
def calculate_vad(cvss_vector, exploitability):
    try:
        vector_parts = cvss_vector.split('/')
        values = {}
        for part in vector_parts:
            metric, value = part.split(':')
            values[metric] = value

        e_value = cvss_v3_metrics['E'][exploitability] if exploitability in cvss_v3_metrics['E'] else cvss_v3_metrics['E']['X']

        vad = 2 * cvss_v3_metrics['AV'][values['AV']] * cvss_v3_metrics['AC'][values['AC']] * \
              cvss_v3_metrics['PR'][values['PR']] * cvss_v3_metrics['UI'][values['UI']] * e_value
        return vad
    except KeyError as e:
        print(f"Error processing CVSS vector: {cvss_vector}, missing key: {e}")
        return None
    except Exception as e:
        print(f"Unexpected error processing CVSS vector: {cvss_vector}, error: {e}")
        return None

# Aplicar la función a cada fila del DataFrame
df['vad'] = df.apply(lambda row: calculate_vad(row['cvss_vector'], row['exploitability']), axis=1)

# Filtrar filas con VAD válidos
df = df.dropna(subset=['vad'])

# Suponemos una conectividad básica entre todas las vulnerabilidades
num_vulnerabilities = len(df)
connectivity_matrix = np.ones((num_vulnerabilities, num_vulnerabilities))

# Multiplicamos los VADs de las vulnerabilidades conectadas para obtener la conectividad Cij
for i in range(num_vulnerabilities):
    for j in range(num_vulnerabilities):
        connectivity_matrix[i, j] *= df.iloc[i]['vad'] * df.iloc[j]['vad']

# Función para calcular el riesgo de correlación
def calculate_correlation_risk(connectivity_matrix, vad_values):
    num_vulnerabilities = len(vad_values)
    risk_vector = np.zeros(num_vulnerabilities)

    for i in range(num_vulnerabilities):
        risk = 0
        for j in range(num_vulnerabilities):
            risk += connectivity_matrix[i, j]
        risk_vector[i] = vad_values[i] * risk
    return risk_vector

# Calcular el riesgo de correlación
vad_values = df['vad'].values
correlation_risk = calculate_correlation_risk(connectivity_matrix, vad_values)
df['correlation_risk'] = correlation_risk

# Guardar los resultados de correlation_risk en la base de datos
df_to_save = df[['result_id', 'correlation_risk']]

# Asegurarse de que la columna correlation_risk exista
cur.execute("""
    ALTER TABLE scan_results
    ADD COLUMN IF NOT EXISTS correlation_risk FLOAT;
""")

# Actualizar la tabla en la base de datos
update_query = """
    UPDATE scan_results
    SET correlation_risk = data.correlation_risk
    FROM (VALUES %s) AS data(result_id, correlation_risk)
    WHERE scan_results.result_id = data.result_id;
"""

# Convertir el DataFrame a una lista de tuplas
values = list(df_to_save.itertuples(index=False, name=None))

# Ejecutar la consulta de actualización
from psycopg2.extras import execute_values
execute_values(cur, update_query, values)

# Confirmar los cambios y cerrar la conexión
conn.commit()
cur.close()
conn.close()

# Comparar correlation_risk con CVSS
df['cvss_diff'] = df['correlation_risk'] - df['cvss']

# Ordenar por la diferencia para identificar discrepancias
df_sorted = df.sort_values(by='cvss_diff', ascending=False)

# Mostrar las vulnerabilidades ordenadas por la diferencia
print(df_sorted[['result_id', 'cve', 'name', 'cvss', 'correlation_risk', 'cvss_diff']])

# Exportar los resultados a un archivo CSV para su análisis
df_sorted[['result_id', 'cve', 'name', 'cvss', 'correlation_risk', 'cvss_diff']].to_csv("./data/vulnerabilidades_priorizadas.csv", index=False)
