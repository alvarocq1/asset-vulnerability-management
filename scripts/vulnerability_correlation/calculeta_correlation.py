import pandas as pd
import numpy as np
from sqlalchemy import create_engine
import psycopg2

# Crear la cadena de conexión usando SQLAlchemy
engine = create_engine('postgresql+psycopg2://acarriq:3432576@localhost:5433/tfg_db')

# Extraer datos de la tabla scan_results
query = "SELECT * FROM scan_results"
df = pd.read_sql_query(query, engine)

# Definir métricas CVSS
cvss_v3_metrics = {
    'AV': {'N': 0.85, 'A': 0.62, 'L': 0.55, 'P': 0.2},
    'AC': {'L': 0.77, 'H': 0.44},
    'PR': {'N': 0.85, 'L': 0.62, 'H': 0.27},  # Assuming Scope Unchanged
    'UI': {'N': 0.85, 'R': 0.62},
    'E': {'X': 1.0}  # Default value for Exploitability
}

cvss_v2_metrics = {
    'AV': {'N': 1.0, 'A': 0.646, 'L': 0.395},
    'AC': {'L': 0.71, 'M': 0.61, 'H': 0.35},
    'Au': {'N': 1.0, 'S': 0.56, 'M': 0.45},
    'E': {'X': 1.0}  # Default value for Exploitability
}

# Función para calcular VAD
def calculate_vad(cvss_vector, cvss_type):
    if cvss_type.lower() == 'cvss_base_v3':
        metrics = cvss_v3_metrics
    elif cvss_type.lower() == 'cvss_base_v2':
        metrics = cvss_v2_metrics
    else:
        return None

    try:
        vector_parts = cvss_vector.split('/')
        values = {}
        for part in vector_parts:
            metric, value = part.split(':')
            values[metric] = value

        if cvss_type.lower() == 'cvss_base_v3':
            vad = 2 * metrics['AV'][values['AV']] * metrics['AC'][values['AC']] * \
                  metrics['PR'][values['PR']] * metrics['UI'][values['UI']] * metrics['E']['X']
        elif cvss_type.lower() == 'cvss_base_v2':
            vad = 2 * metrics['AV'][values['AV']] * metrics['AC'][values['AC']] * \
                  metrics['Au'][values['Au']] * metrics['E']['X']
        return vad
    except KeyError as e:
        print(f"Error processing CVSS vector: {cvss_vector}, missing key: {e}")
        return None
    except Exception as e:
        print(f"Unexpected error processing CVSS vector: {cvss_vector}, error: {e}")
        return None

# Aplicar la función a cada fila del DataFrame
df['vad'] = df.apply(lambda row: calculate_vad(row['cvss_vector'], row['cvss_type']), axis=1)

# Filtrar filas con VAD válidos
df = df.dropna(subset=['vad'])

# Suponemos una conectividad básica entre todas las vulnerabilidades
num_vulnerabilities = len(df)
connectivity_matrix = np.ones((num_vulnerabilities, num_vulnerabilities))

# Multiplicamos los VADs de las vulnerabilidades conectadas para obtener la conectividad Cij
for i in range(num_vulnerabilities):
    for j in range(num_vulnerabilities):
        connectivity_matrix[i, j] *= df.iloc[i]['vad'] * df.iloc[j]['vad']

# Función para calcular el riesgo de correlación
def calculate_correlation_risk(connectivity_matrix, vad_values):
    num_vulnerabilities = len(vad_values)
    risk_vector = np.zeros(num_vulnerabilities)

    for i in range(num_vulnerabilities):
        risk = 0
        for j in range(num_vulnerabilities):
            risk += connectivity_matrix[i, j]
        risk_vector[i] = vad_values[i] * risk
    return risk_vector

# Calcular el riesgo de correlación
vad_values = df['vad'].values
correlation_risk = calculate_correlation_risk(connectivity_matrix, vad_values)
df['correlation_risk'] = correlation_risk

# Guardar los resultados de correlation_risk en la base de datos
df_to_save = df[['result_id', 'correlation_risk']]

# Conectar a la base de datos y actualizar la tabla
conn = psycopg2.connect(
    dbname="tfg_db",
    user="acarriq",
    password="3432576",
    host="localhost",
    port="5433"
)
cur = conn.cursor()

# Asegurarse de que la columna correlation_risk exista
cur.execute("""
    ALTER TABLE scan_results
    ADD COLUMN IF NOT EXISTS correlation_risk FLOAT;
""")

# Actualizar la tabla en la base de datos
update_query = """
    UPDATE scan_results
    SET correlation_risk = data.correlation_risk
    FROM (VALUES %s) AS data(result_id, correlation_risk)
    WHERE scan_results.result_id = data.result_id;
"""

# Convertir el DataFrame a una lista de tuplas
values = list(df_to_save.itertuples(index=False, name=None))

# Ejecutar la consulta de actualización
from psycopg2.extras import execute_values
execute_values(cur, update_query, values)

# Confirmar los cambios y cerrar la conexión
conn.commit()
cur.close()
conn.close()

# Comparar correlation_risk con CVSS
df['cvss_diff'] = df['correlation_risk'] - df['cvss']

# Ordenar por la diferencia para identificar discrepancias
df_sorted = df.sort_values(by='cvss_diff', ascending=False)

# Mostrar las vulnerabilidades ordenadas por la diferencia
print(df_sorted[['result_id', 'name', 'cvss', 'correlation_risk', 'cvss_diff']])

# Exportar los resultados a un archivo CSV para su análisis
df_sorted.to_csv("vulnerabilidades_priorizadas.csv", index=False)
