import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Leer el archivo CSV generado
df = pd.read_csv('src/data/vulnerabilidades_priorizadas.csv')

# Filtrar por ip_address
df = df[df['ip_address'] == '192.168.1.161']

# Calcular los rangos y colores para final_priority_score
priority_score_ranges = {
    'Low': (0.0, df['final_priority_score'].quantile(0.25)),
    'Medium': (df['final_priority_score'].quantile(0.25), df['final_priority_score'].quantile(0.5)),
    'High': (df['final_priority_score'].quantile(0.5), df['final_priority_score'].quantile(0.75)),
    'Critical': (df['final_priority_score'].quantile(0.75), df['final_priority_score'].max())
}
priority_colors = {
    'Low': 'green',
    'Medium': 'yellow',
    'High': 'orange',
    'Critical': 'red'
}

# Imprimir los rangos para verificar
print("Priority Score Ranges:", priority_score_ranges)

# Función para asignar la categoría basada en final_priority_score
def get_priority_category(score):
    for priority, (low, high) in priority_score_ranges.items():
        if low <= score <= high:
            return priority
    return 'Unknown'

# Aplicar la función para obtener las categorías
df['priority_category'] = df['final_priority_score'].apply(get_priority_category)

# Imprimir algunos valores para verificar
print(df[['final_priority_score', 'priority_category']].head(10))

# Normalizar cvss y final_priority_score al rango 0-10
normalized_cvss = (df['cvss'] - df['cvss'].min()) / (df['cvss'].max() - df['cvss'].min()) * 10
normalized_fps = (df['final_priority_score'] - df['final_priority_score'].min()) / (df['final_priority_score'].max() - df['final_priority_score'].min()) * 10

# Calcular la diferencia absoluta entre las métricas normalizadas
df['diff_abs'] = abs(normalized_cvss - normalized_fps)

# Normalizar los valores de diff_abs para el tamaño de los puntos
size_min, size_max = 40, 400
df['size'] = ((df['diff_abs'] - df['diff_abs'].min()) / (df['diff_abs'].max() - df['diff_abs'].min())) * (size_max - size_min) + size_min

# Configuración de estilo para seaborn
sns.set(style="whitegrid")

# Crear un gráfico de dispersión para visualizar la relación entre CVSS y Final Priority Score
plt.figure(figsize=(12, 8))
scatter = sns.scatterplot(
    data=df, 
    x='cvss', 
    y='final_priority_score', 
    hue='priority_category', 
    size='size', 
    sizes=(size_min, size_max),
    palette=priority_colors
)

# Añadir etiquetas y título
plt.xlabel('CVSS Score')
plt.ylabel('Final Priority Score')

# Personalizar las etiquetas de la leyenda
h, l = scatter.get_legend_handles_labels()
new_labels = ['Nivel de prioridad' if label == 'priority_category' else 
              'Diferencia entre CVSS y prioridad final' if label == 'size' else label 
              for label in l]
plt.legend(h, new_labels, bbox_to_anchor=(1.05, 1), loc='upper left')

# Guardar el gráfico como una imagen
plt.savefig('src/figures/relacion_cvss_correlation_risk.png', bbox_inches='tight')

# Mostrar el gráfico
plt.show()
