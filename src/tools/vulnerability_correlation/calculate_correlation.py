import pandas as pd
import numpy as np
import psycopg2

from src.config.config import *

# Conexión a la base de datos
print("Connecting to the database...")
conn = psycopg2.connect(
    dbname=DB_NAME,
    user=DB_USER,
    password=DB_PASSWORD,
    host=DB_HOST,
    port=DB_PORT
)

# Crear un cursor
cur = conn.cursor()

# Extraer datos de la tabla scan_results
query = "SELECT * FROM scan_results WHERE cvss_type = 'cvss_base_v3'"
df = pd.read_sql_query(query, conn)
# Imprimir los nombres de las columnas para verificar
print("Column names in the DataFrame:", df.columns.tolist())
# Definir métricas CVSS 3.1
cvss_v3_metrics = {
    'AV': {'N': 0.85, 'A': 0.62, 'L': 0.55, 'P': 0.2},
    'AC': {'L': 0.77, 'H': 0.44},
    'PR': {
        'N': 0.85,
        'L': {'unchanged': 0.62, 'changed': 0.68},
        'H': {'unchanged': 0.27, 'changed': 0.5}
    },
    'UI': {'N': 0.85, 'R': 0.62},
    'E': {'X': 1.0, 'H': 1.0, 'F': 0.97, 'P': 0.94, 'U': 0.91}  # Valores actualizados para Exploitability
}


solution_factors = {'VendorFix': 1.5, 'Mitigation': 1.2, 'Workaround': 1.0, 'WillNotFix': 0.7}

# Función para calcular VAD
def calculate_vad(cvss_vector, exploitability):
    try:
        vector_parts = cvss_vector.split('/')
        values = {}
        for part in vector_parts:
            metric, value = part.split(':')
            values[metric] = value

        e_value = cvss_v3_metrics['E'][exploitability] if exploitability in cvss_v3_metrics['E'] else cvss_v3_metrics['E']['X']
        
        pr_value = cvss_v3_metrics['PR'][values['PR']]
        if values['PR'] in ['L', 'H']:
            pr_value = pr_value['changed'] if 'S:C' in values else pr_value['unchanged']

        vad = 2 * cvss_v3_metrics['AV'][values['AV']] * cvss_v3_metrics['AC'][values['AC']] * \
              pr_value * cvss_v3_metrics['UI'][values['UI']] * e_value
        return vad
    except KeyError as e:
        print(f"Error processing CVSS vector: {cvss_vector}, missing key: {e}")
        return None
    except Exception as e:
        print(f"Unexpected error processing CVSS vector: {cvss_vector}, error: {e}")
        return None

# Aplicar la función a cada fila del DataFrame
df['vad'] = df.apply(lambda row: calculate_vad(row['cvss_vector'], row['exploitability']), axis=1)

# Filtrar filas con VAD válidos
df = df.dropna(subset=['vad'])

# Suponemos una conectividad básica entre todas las vulnerabilidades
num_vulnerabilities = len(df)
connectivity_matrix = np.ones((num_vulnerabilities, num_vulnerabilities))

# Multiplicamos los VADs de las vulnerabilidades conectadas para obtener la conectividad Cij
for i in range(num_vulnerabilities):
    for j in range(num_vulnerabilities):
        connectivity_matrix[i, j] *= df.iloc[i]['vad'] * df.iloc[j]['vad']

# Función para calcular el riesgo de correlación
def calculate_correlation_risk(connectivity_matrix, vad_values):
    num_vulnerabilities = len(vad_values)
    risk_vector = np.zeros(num_vulnerabilities)

    for i in range(num_vulnerabilities):
        risk = 0
        for j in range(num_vulnerabilities):
            risk += connectivity_matrix[i, j]
        risk_vector[i] = vad_values[i] * risk
    return risk_vector

# Calcular el riesgo de correlación
vad_values = df['vad'].values
correlation_risk = calculate_correlation_risk(connectivity_matrix, vad_values)
df['correlation_risk'] = correlation_risk

# Calcular la puntuación de prioridad final
df['solution_factor'] = df['solution_type'].map(solution_factors).fillna(solution_factors['WillNotFix'])

df['final_priority_score'] = df['correlation_risk'] * df['solution_factor']

# Guardar los resultados de correlation_risk y final_priority_score en la base de datos
df_to_save = df[['result_id', 'correlation_risk', 'final_priority_score']]

# Asegurarse de que las columnas correlation_risk y final_priority_score existan
cur.execute("""
    ALTER TABLE scan_results
    ADD COLUMN IF NOT EXISTS correlation_risk FLOAT,
    ADD COLUMN IF NOT EXISTS final_priority_score FLOAT;
""")

# Actualizar la tabla en la base de datos
update_query = """
    UPDATE scan_results
    SET correlation_risk = data.final_priority_score,
        final_priority_score = data.final_priority_score
    FROM (VALUES %s) AS data(result_id, correlation_risk, final_priority_score)
    WHERE scan_results.result_id = data.result_id;
"""

# Convertir el DataFrame a una lista de tuplas
values = list(df_to_save.itertuples(index=False, name=None))

# Ejecutar la consulta de actualización
from psycopg2.extras import execute_values
execute_values(cur, update_query, values)

# Confirmar los cambios y cerrar la conexión
conn.commit()
cur.close()
conn.close()

# Comparar final_priority_score con CVSS
df['cvss_diff'] = df['final_priority_score'] - df['cvss']

# Ordenar por la diferencia para identificar discrepancias
df_sorted = df.sort_values(by='cvss_diff', ascending=False)

# Mostrar las vulnerabilidades ordenadas por la diferencia
print(df_sorted[['result_id', 'cves', 'name', 'cvss', 'correlation_risk', 'final_priority_score', 'cvss_diff']])

# Exportar los resultados a un archivo CSV para su análisis
df_sorted[['result_id', 'cves', 'ip_address' , 'name', 'cvss', 'correlation_risk', 'final_priority_score', 'cvss_diff']].to_csv("src/data/vulnerabilidades_priorizadas.csv", index=False)
