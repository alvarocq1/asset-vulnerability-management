import requests
import csv
import time

from config.config import *

# Configura tu clave API y la URL base de la NVD
api_key = 'c54455ca-28f6-4222-88c3-facda15ed7b6'
base_url = 'https://services.nvd.nist.gov/rest/json/cves/2.0'

# Define los parámetros de la solicitud
params = {
    'resultsPerPage': 1,  # Solo necesitamos un resultado para obtener totalResults
    'startIndex': 0
}

# Realiza una solicitud inicial para obtener totalResults
headers = {'apiKey': api_key}
try:
    response = requests.get(base_url, headers=headers, params=params)
    response.raise_for_status()  # Levanta un error para códigos de estado HTTP 4xx/5xx
    initial_data = response.json()
    total_results = initial_data['totalResults']
    print(f"Total de resultados disponibles: {total_results}")
except requests.exceptions.RequestException as err:
    print(f"Error durante la solicitud inicial: {err}")
    total_results = 0

# Ajusta los parámetros para la extracción completa
params['resultsPerPage'] = 2000

# Función para extraer puntuaciones y vectores CVSS de los datos
def extract_cvss_scores(metrics):
    cvss_v2 = cvss_v2_vector = None
    cvss_v30 = cvss_v30_vector = None
    cvss_v31 = cvss_v31_vector = None
    
    if 'cvssMetricV2' in metrics:
        cvss_v2 = metrics['cvssMetricV2'][0]['cvssData']['baseScore']
        cvss_v2_vector = metrics['cvssMetricV2'][0]['cvssData']['vectorString']
        
    if 'cvssMetricV30' in metrics:
        cvss_v30 = metrics['cvssMetricV30'][0]['cvssData']['baseScore']
        cvss_v30_vector = metrics['cvssMetricV30'][0]['cvssData']['vectorString']
        
    if 'cvssMetricV31' in metrics:
        cvss_v31 = metrics['cvssMetricV31'][0]['cvssData']['baseScore']
        cvss_v31_vector = metrics['cvssMetricV31'][0]['cvssData']['vectorString']
    
    return cvss_v2, cvss_v2_vector, cvss_v30, cvss_v30_vector, cvss_v31, cvss_v31_vector

# Abre el archivo CSV para escribir los datos
with open('cves_actualizados.csv', mode='w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(['CVE ID', 'CVSS 2.0 Base Score', 'CVSS 2.0 Vector', 'CVSS 3.0 Base Score', 'CVSS 3.0 Vector', 'CVSS 3.1 Base Score', 'CVSS 3.1 Vector'])

    total_cves = 0
    extracted_cves = 0

    while total_cves < total_results:
        headers = {'apiKey': api_key}
        retries = 5  # Número máximo de reintentos

        while retries > 0:
            try:
                response = requests.get(base_url, headers=headers, params=params)
                response.raise_for_status()  # Levanta un error para códigos de estado HTTP 4xx/5xx
                data = response.json()
                break  # Salir del bucle si la solicitud es exitosa
            except requests.exceptions.HTTPError as errh:
                print(f"HTTP Error: {errh}")
                if response.status_code == 503:
                    retries -= 1
                    print(f"Reintentando... (quedan {retries} reintentos)")
                    time.sleep(10)  # Espera 10 segundos antes de reintentar
                    continue
                else:
                    break
            except requests.exceptions.ConnectionError as errc:
                print(f"Error Connecting: {errc}")
                retries -= 1
                time.sleep(10)  # Espera 10 segundos antes de reintentar
                continue
            except requests.exceptions.Timeout as errt:
                print(f"Timeout Error: {errt}")
                retries -= 1
                time.sleep(10)  # Espera 10 segundos antes de reintentar
                continue
            except requests.exceptions.RequestException as err:
                print(f"Error: {err}")
                break
            except ValueError as e:
                print(f"Error parsing JSON: {e}")
                print(f"Response content: {response.text}")
                break
        
        if retries == 0:
            print("Máximo número de reintentos alcanzado. Terminando el proceso.")
            break

        if 'vulnerabilities' not in data:
            break

        total_cves += len(data['vulnerabilities'])
        
        # Itera sobre cada CVE y escribe en el archivo CSV aquellos con puntuaciones CVSS 2.0 y 3.1, o 3.0 y 3.1
        for item in data['vulnerabilities']:
            cve_item = item['cve']
            cve_id = cve_item['id']
            metrics = cve_item.get('metrics', {})
            
            cvss_v2, cvss_v2_vector, cvss_v30, cvss_v30_vector, cvss_v31, cvss_v31_vector = extract_cvss_scores(metrics)
            
            # Incluir solo los CVEs que tienen CVSS 2.0 y 3.1, o CVSS 3.0 y 3.1
            if (cvss_v2 is not None and cvss_v31 is not None) or (cvss_v30 is not None and cvss_v31 is not None):
                writer.writerow([cve_id, cvss_v2, cvss_v2_vector, cvss_v30, cvss_v30_vector, cvss_v31, cvss_v31_vector])
                extracted_cves += 1

        # Actualiza el índice de inicio para la próxima solicitud
        params['startIndex'] += 2000
        
        # Verifica si hemos llegado al final de los resultados
        if len(data['vulnerabilities']) < 2000:
            break
        
        # Pausa el script para evitar exceder el límite de tasa de solicitudes
        time.sleep(6)

        # Imprime el estado de la extracción
        print(f"Total de CVEs procesados: {total_cves}, CVEs extraídos: {extracted_cves}")

print("Proceso completado. Los datos se han guardado en 'cves_actualizados.csv'.")
print(f"Total de CVEs procesados: {total_cves}, CVEs extraídos: {extracted_cves}")
