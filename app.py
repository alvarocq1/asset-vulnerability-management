from flask import Flask, render_template, request, redirect, url_for, jsonify, send_from_directory, session
from flask_socketio import SocketIO, emit
import subprocess
import psycopg2
from datetime import datetime, timedelta
from src.config.config import DB_NAME, DB_USER, DB_PASSWORD, DB_HOST, DB_PORT
from src.utils.check_connections import check_postgresql_connection, check_openvas_connection
import os
import logging
import decimal

# Configurar registro
logging.basicConfig(level=logging.DEBUG)

app = Flask(__name__, static_folder='static', template_folder='templates')
app.secret_key = 'your_secret_key'
socketio = SocketIO(app)

# Variable para almacenar el estado del escaneo
scan_status = {
    'scanning': False,
    'progress': 0,
    'message': ''
}

def update_scan_status(scanning, progress, message):
    scan_status['scanning'] = scanning
    scan_status['progress'] = progress
    scan_status['message'] = message
    socketio.emit('scan_update', scan_status)

def get_cves_from_scan_results(ip_address=None):
    logging.debug("Obteniendo CVEs de los resultados del escaneo")
    try:
        conn = psycopg2.connect(
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT
        )
        cursor = conn.cursor()
        if ip_address:
            cursor.execute("SELECT result_id, cve, cvss, COALESCE(correlation_risk, 0.0) FROM scan_results WHERE host = %s ORDER BY correlation_risk DESC", (ip_address,))
        else:
            cursor.execute("SELECT result_id, cve, cvss, COALESCE(correlation_risk, 0.0) FROM scan_results ORDER BY correlation_risk DESC")
        cves = cursor.fetchall()
        cursor.close()
        conn.close()
        logging.debug(f"CVEs obtenidos: {cves}")
        return cves
    except Exception as e:
        logging.error(f"Error al conectar a la base de datos: {e}")
        return []

def get_scan_metadata(ip_address=None):
    logging.debug("Obteniendo metadatos del último escaneo")
    try:
        conn = psycopg2.connect(
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT
        )
        cursor = conn.cursor()
        if ip_address:
            cursor.execute("""
                SELECT COUNT(*), SUM(EXTRACT(EPOCH FROM (end_time - start_time))) / 60 AS scan_time 
                FROM scan_times WHERE ip_address = %s
            """, (ip_address,))
        else:
            cursor.execute("""
                SELECT COUNT(*), SUM(EXTRACT(EPOCH FROM (end_time - start_time))) / 60 AS scan_time 
                FROM scan_times
            """)
        metadata = cursor.fetchone()
        cursor.close()
        conn.close()
        logging.debug(f"Metadatos obtenidos: {metadata}")
        return metadata
    except Exception as e:
        logging.error(f"Error al conectar a la base de datos: {e}")
        return None, None

def get_last_scan():
    logging.debug("Obteniendo la última hora de escaneo")
    try:
        conn = psycopg2.connect(
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT
        )
        cursor = conn.cursor()
        cursor.execute("SELECT MAX(end_time) FROM scan_times")
        last_scan = cursor.fetchone()
        cursor.close()
        conn.close()
        logging.debug(f"Última hora de escaneo: {last_scan}")
        return last_scan[0] if last_scan else None
    except Exception as e:
        logging.error(f"Error al conectar a la base de datos: {e}")
        return None

def get_cve_details(result_id):
    logging.debug(f"Obteniendo detalles del CVE para result_id: {result_id}")
    try:
        conn = psycopg2.connect(
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT
        )
        cursor = conn.cursor()
        cursor.execute("""
            SELECT result_id, name, host, port, cvss, qod, solution_type, cvss_type, cvss_vector, exploitability
            FROM scan_results WHERE result_id = %s
        """, (result_id,))
        details = cursor.fetchone()
        cursor.close()
        conn.close()
        logging.debug(f"Detalles obtenidos: {details}")
        return details
    except Exception as e:
        logging.error(f"Error al conectar a la base de datos: {e}")
        return None

def get_assets():
    logging.debug("Obteniendo activos")
    try:
        conn = psycopg2.connect(
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT
        )
        cursor = conn.cursor()
        cursor.execute("SELECT ip_address, os FROM assets")
        assets = cursor.fetchall()
        cursor.close()
        conn.close()
        logging.debug(f"Activos obtenidos: {assets}")
        return assets
    except Exception as e:
        logging.error(f"Error al conectar a la base de datos: {e}")
        return []

@app.route('/')
def index():
    logging.debug("Cargando la página de inicio")
    last_scan = get_last_scan()
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return render_template('index.html', last_scan=last_scan, current_time=current_time, scan_status=scan_status)

@app.route('/run_pipeline', methods=['POST'])
def run_pipeline():
    logging.debug("Ejecutando el pipeline")
    steps = [
        ('Iniciando escaneo de activos...', 'src/tools/vulnerability_analysis/delete_scans.py'),
        ('Limpiando los tasks anteriores...', 'src/tools/vulnerability_analysis/clean_tasks.py'),
        ('Escaneando activos con OpenVAS...', 'src/tools/vulnerability_analysis/openvas_scan.py'),
        ('Guardando resultados del escaneo...', 'src/tools/vulnerability_analysis/fetch_and_store_results.py'),
        ('Convirtiendo los scans...', 'src/models/convert_scans.py'),
        ('Ejecutando script de Metasploit...', 'src/tools/metasploit/set_exploitability_metric.py'),
        ('Calculando la correlación...', 'src/tools/vulnerability_correlation/calculate_correlation.py'),
        ('Generando gráficos...', 'src/tools/analysis/cves_plot.py')
    ]

    update_scan_status(True, 0, 'Iniciando escaneo de activos...')

    for i, (message, script) in enumerate(steps):
        logging.debug(message)
        update_scan_status(True, int((i / len(steps)) * 100), message)
        subprocess.run(['python', script])
    
    update_scan_status(False, 100, 'Escaneo completado.')

    # Registrar la hora del escaneo
    try:
        conn = psycopg2.connect(
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT
        )
        cursor = conn.cursor()
        cursor.execute("INSERT INTO scan_metadata (scan_time) VALUES (%s)", ('30 minutes',))
        conn.commit()
        cursor.close()
        conn.close()
        logging.debug("Hora del escaneo registrada")
    except Exception as e:
        logging.error(f"Error al registrar la hora del escaneo: {e}")
    
    return redirect(url_for('index'))

@app.route('/show_cves', methods=['GET'])
def show_cves():
    logging.debug("Mostrando CVEs")
    cves = get_cves_from_scan_results()
    return render_template('cves.html', cves=cves)

@app.route('/cve_details/<result_id>', methods=['GET'])
def cve_details(result_id):
    logging.debug(f"Mostrando detalles del CVE para result_id: {result_id}")
    details = get_cve_details(result_id)
    return render_template('cve_details.html', result_id=result_id, details=details)

@app.route('/show_assets', methods=['GET'])
def show_assets():
    logging.debug("Mostrando activos")
    assets = get_assets()
    return render_template('assets.html', assets=assets)

@app.route('/correlation_analysis', methods=['GET'])
def correlation_analysis():
    logging.debug("Mostrando análisis de correlación")
    return render_template('correlation_analysis.html')

@app.route('/figures/<filename>')
def figures(filename):
    logging.debug(f"Mostrando figura: {filename}")
    return send_from_directory('src/figures/cvss_distribution', filename)

@app.route('/analysis')
def analysis():
    logging.debug("Mostrando análisis del último escaneo")
    view = request.args.get('view', 'general')
    if view == 'general':
        total_vulnerabilities, scan_time_seconds = get_scan_metadata()
        cves = get_cves_from_scan_results()
        image_file = 'general_cvss_distribution.png'
    else:
        total_vulnerabilities, scan_time_seconds = get_scan_metadata(view)
        cves = get_cves_from_scan_results(view)
        image_file = f'{view.replace(".", "_")}_cvss_distribution.png'
    assets = get_assets()

    # Convertir segundos a un formato legible
    if scan_time_seconds is not None:
        scan_time_seconds = float(scan_time_seconds) * 60
        scan_time = str(timedelta(seconds=scan_time_seconds))
    else:
        scan_time = "N/A"
    
    return render_template('analysis.html', total_vulnerabilities=total_vulnerabilities, scan_time=scan_time, cves=cves, image_file=image_file, assets=assets, selected_view=view)

@app.route('/check_status', methods=['GET'])
def check_status():
    logging.debug("Verificando estado de las conexiones")
    db_status = check_postgresql_connection()
    openvas_status = check_openvas_connection()
    return jsonify({'db_status': db_status, 'openvas_status': openvas_status})

@socketio.on('start_scan')
def start_scan():
    logging.debug("Escaneo iniciado a través de WebSocket")
    update_scan_status(True, 0, 'Iniciando escaneo de activos...')
    socketio.start_background_task(target=run_pipeline)

if __name__ == "__main__":
    socketio.run(app, debug=True)
