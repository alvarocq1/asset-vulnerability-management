import pandas as pd
import joblib
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline

# Función para extraer y mapear los vectores CVSS a sus componentes
def extract_cvss_components(cvss_vector):
    if pd.isna(cvss_vector):
        return {}
    components = cvss_vector.split('/')
    components_dict = {}
    for comp in components:
        key, value = comp.split(':')
        components_dict[key] = value
    return components_dict

# Vector CVSS 2.0 para predicción
vector_2_0 = 'AV:N/AC:L/Au:M/C:N/I:P/A:N'

# Extraer los componentes del vector CVSS 2.0
components_2_0 = extract_cvss_components(vector_2_0)
input_df = pd.DataFrame([components_2_0])

# Cargar el modelo entrenado, los codificadores de etiquetas y el ColumnTransformer
best_models, label_encoders, column_transformer = joblib.load('best_models_knn_classification.pkl')

# Transformar las características de entrada
input_transformed = column_transformer.transform(input_df)

# Realizar la predicción para cada componente del vector CVSS 3.1
predicted_vector_3_1 = {}
cvss_3_1_columns = ['AV', 'AC', 'PR', 'UI', 'S', 'C', 'I', 'A']

for col in cvss_3_1_columns:
    if f"kNN_col_{col}" in best_models:
        model = best_models[f"kNN_col_{col}"]
        le = label_encoders[col]
        
        # Realizar la predicción
        prediction_encoded = model.predict(input_transformed)[0]
        prediction = le.inverse_transform([prediction_encoded])[0]
        predicted_vector_3_1[col] = prediction
    else:
        print(f"Modelo para {col} no encontrado en best_models.")

# Formatear el resultado predicho
formatted_output = '/'.join([f"{col}:{predicted_vector_3_1[col]}" for col in cvss_3_1_columns])
print(f"Predicción del vector CVSS 3.1: {formatted_output}")
